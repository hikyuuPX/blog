---
id: C_struct_size
slug: /C_struct_size
title: C 结构体字节数
date: 2022-11-07
authors: nox
tags: [C/C++]
keywords: [C/C++]
---

<!-- truncate -->

## 1. 字节概念

### 1.1 CPU字长

字长的概念念指的是处理器在一条指令中的数据处理能力，当然这个能力还需要搭配操作系统的设定，比如常见的32位系统、64位系统，指的是在此系统环境下，处理器一次存储处理的数据可以达32位或64位。

### 1.2 地址对齐

CPU字长确定之后，相当于明确了系统每次存取内存数据时的边界，以32位系统为例，32位意味着CPU每次存取都以4字节为边界，因此每4字节可以认为是CPU存取内存数据的一个单元。

如果存取的数据刚好落在所需单元数之内，那么我们就说这个数据的地址是对齐的，如果存取的数跨越了边界，使用了超过所需单元的字节，那么我们就说这个数据的地址是未对齐的。

注意：`64位系统是以8字节为边界`

![ZfmDID.png](https://www.helloimg.com/images/2022/11/07/ZfmDID.png)

图中一个小方格代表一个字节。从图中可以明显看出，数据本身占据了8个字节，在地址未对齐的情况下，CPU需要分3次才能完整地存取完这个数据，但是在地址对齐的情况下，CPU可以分2次就能完整地存取这个数据。

## 2. 字节数与m值

### 2.1 数据类型在不同系统中所占字节数

| 数据类型  | Linux32 | Linux64 |
| :-------: | :-----: | :-----: |
|   char    |    1    |    1    |
|   short   |    2    |    2    |
|    int    |    4    |    4    |
|   long    |    4    |    8    |
| long long |    8    |    8    |
|   float   |    4    |    4    |
|  double   |    8    |    8    |
|  void *   |    4    |    8    |

### 2.2 普通变量的m值

以32位系统为例，由于CPU存取数据总是以4字节为单元，因此对于一个尺寸固定的数据而言，当它的地址满足某个数的整数倍时，就可以保证地址对齐。这个数就被称为变量的m值。

+ 根据具体系统的字长，和数据本身的尺寸，m值是可以很简单计算出来的。

```jsx showLineNumbers
char c; 	// 由于c占1个字节，因此c不管放哪里地址都是对齐的，因此m=1
short s; 	// 由于s占2个字节，因此s地址只要是偶数就是对齐的，因此m=2
int i; 		// 由于i占4个字节，因此只要i地址满足4的倍数就是对齐的，因此m=4
double f; 	// 由于f占8个字节，因此只要f地址满足4的倍数就是对齐的，因此m=4

printf("%p\n", &c); // &c = 1*N，即：c的地址一定满足1的整数倍
printf("%p\n", &s); // &s = 2*N，即：s的地址一定满足2的整数倍
printf("%p\n", &i); // &i = 4*N，即：i的地址一定满足4的整数倍
printf("%p\n", &f); // &f = 4*N，即：f的地址一定满足4的整数倍
```

注意：`变量的m值跟变量本身的尺寸有关，但它们是两个不同的概念。`

而在64位系统中，CPU存取数据是以8字节为单元，所以在32位系统中以4字节对齐的double、long，在64位中是以8字节来对齐的。

+ 手动干预变量的m值，让它以你设定的字节数对齐。

```jsx showLineNumbers
 char c __attribute__((aligned(32))); // 将变量 c 的m值设置为32
```

## 3. 结构体所占字节数

### 3.1 空结构体所占字节

```jsx showLineNumbers
struct struct_null
{
	
};
```

在**ubunt16.04**中字节长度中为0，根据具体的编译环境有变化.

### 3.2 结构体所占字节分析

结构体的m值。取决于其成员的m值的最大值。即 m = max{m1, m2, m3, ...}。

结构体的和地址和尺寸，都必须等于m的整数倍。

```jsx showLineNumbers
struct s_size
{
	short a; 	// 32位：字节 2，m值=2    64位：字节 2，m值=2
	double b; 	// 32位：字节 8，m值=4    64位：字节 8，m值=8
	char c; 	// 32位：字节 1，m值=1    64位：字节 1，m值=1
    short d;    // 32位：字节 2，m值=2    64位：字节 2，m值=2
};

struct s_size size; // 32位：m值 = max{2, 4, 1} = 4   64位：m值 = max{2, 8, 1} = 8
```

所以分析上述结构体成员存储：

+ 结构体的M值等于4，这意味着结构体的地址、尺寸都必须满足4的倍数。
+ 成员a的m值等于2，但a作为结构体的首元素，必须满足M值约束，即a的地址必须是4的倍数。
+ 成员b的m值等于4，因此在a和b之间，需要填充2个字节的无效数据（一般填充0）
+ 成员c的m值等于1，因此c紧挨在b的后面，占一个字节。
+ 成员d的m值等于2，因为结构体的m值为4，所以在c和d之间会填充一个空字节，凑够4。

![ZfsXZm.png](https://www.helloimg.com/images/2022/11/07/ZfsXZm.png)

64位系统同理，只不过64位m值为8.

> 所以在32位系统中，该结构体尺寸大小为12Byte，在64位系统中为24Byte。

## 4. 联合体所占字节数

+ 联合体中的各个成员共用一片空间，但它们也遵循着m值对齐的方式

```jsx showLineNumbers
union u_size
{
	int a[5];		// 32位：字节 4*5=20，m值=4    64位：字节 4*5=20，m值=4
	double b;		// 32位：字节 4，m值=4         64位：字节 8，m值=8
};

union u_size u; 	// 32位：m值 = max{4, 4} = 4      64位：m值 = max{4, 8} = 8
```

所以该联合体在32位系统中所占字节数为20Byte，可以被为4的m值整除。

在64位系统中所占字节为24Byte，可以被为8的m值整除。

## 5. 结构体跟联合体一起所占字节

分析结构体所占字节数：

```jsx showLineNumbers
union u_size
{
	int a[5];			// 32位：字节 4*5=20，m值=4    64位：字节 4*5=20，m值=4
	double b;			// 32位：字节 4，m值=4         64位：字节 8，m值=8
};

struct s_size
{
	short a; 			// 32位：字节 2，m值=2    64位：字节 2，m值=2
	double b; 			// 32位：字节 8，m值=4    64位：字节 8，m值=8
    union u_size u;		// 32位：字节 20，m值=4   64位：字节 24，m值=8
	char c; 			// 32位：字节 1，m值=1    64位：字节 1，m值=1
    short d;    		// 32位：字节 2，m值=2    64位：字节 2，m值=2
};

struct s_size size; // 32位：m值 = max{2, 4, 1} = 4   64位：m值 = max{2, 8, 1} = 8
```

所以该结构体在32位系统中所占字节数为36Byte。

在64位系统中所占字节数为48Byte。



















